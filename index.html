<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>AR –ñ–µ—Å—Ç-–®—É—Ç–µ—Ä</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Roboto:wght@300;400;700&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            overflow: hidden;
            background: #000;
            font-family: 'Roboto', sans-serif;
        }
        
        #loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0a0a0f 0%, #1a1a2e 50%, #0f0f23 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            transition: opacity 0.8s ease-out;
        }
        
        #loading-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        .loader-container {
            position: relative;
            width: 200px;
            height: 200px;
        }
        
        .loader-ring {
            position: absolute;
            width: 100%;
            height: 100%;
            border: 3px solid transparent;
            border-radius: 50%;
            animation: spin 2s linear infinite;
        }
        
        .loader-ring:nth-child(1) { border-top-color: #ff3366; animation-duration: 1.5s; }
        .loader-ring:nth-child(2) { width: 80%; height: 80%; top: 10%; left: 10%; border-right-color: #00ffcc; animation-duration: 2s; animation-direction: reverse; }
        .loader-ring:nth-child(3) { width: 60%; height: 60%; top: 20%; left: 20%; border-bottom-color: #ffcc00; animation-duration: 1s; }
        
        .loader-icon {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            filter: drop-shadow(0 0 20px #ff3366);
        }
        
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        .loading-title {
            font-family: 'Orbitron', monospace;
            font-size: 28px;
            font-weight: 900;
            color: #fff;
            margin-top: 40px;
            text-transform: uppercase;
            letter-spacing: 6px;
            text-shadow: 0 0 30px #ff3366;
        }
        
        .loading-status { font-size: 18px; color: #00ffcc; margin-top: 20px; letter-spacing: 2px; }
        .loading-bar-container { width: 300px; height: 4px; background: #1a1a2e; border-radius: 2px; margin-top: 30px; overflow: hidden; }
        .loading-bar { height: 100%; width: 0%; background: linear-gradient(90deg, #ff3366, #ffcc00, #00ffcc); transition: width 0.3s; }
        
        #background {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 0;
            background: linear-gradient(135deg, #0c0c1e 0%, #1a0a2e 30%, #0a1628 60%, #0f0a20 100%);
        }
        
        .bg-stars {
            position: absolute;
            width: 100%; height: 100%;
            background-image: 
                radial-gradient(2px 2px at 20px 30px, #fff, transparent),
                radial-gradient(2px 2px at 40px 70px, rgba(255,255,255,0.8), transparent),
                radial-gradient(1px 1px at 90px 40px, #fff, transparent),
                radial-gradient(2px 2px at 160px 120px, rgba(255,255,255,0.6), transparent);
            background-size: 200px 150px;
            animation: twinkle 5s ease-in-out infinite;
        }
        
        @keyframes twinkle { 0%, 100% { opacity: 0.7; } 50% { opacity: 1; } }
        
        .bg-nebula {
            position: absolute;
            width: 150%; height: 150%;
            top: -25%; left: -25%;
            background: 
                radial-gradient(ellipse at 20% 80%, rgba(255,51,102,0.15) 0%, transparent 50%),
                radial-gradient(ellipse at 80% 20%, rgba(0,255,204,0.1) 0%, transparent 40%);
            animation: nebulaFloat 20s ease-in-out infinite;
        }
        
        @keyframes nebulaFloat { 0%, 100% { transform: translate(0, 0); } 50% { transform: translate(2%, 2%); } }
        
        #camera-pip {
            position: fixed;
            bottom: 15px; left: 15px;
            width: 220px; height: 165px;
            border-radius: 12px;
            overflow: hidden;
            border: 3px solid #ff3366;
            box-shadow: 0 0 20px rgba(255,51,102,0.5);
            z-index: 10;
        }
        
        #webcam {
            position: absolute;
            width: 100%; height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }
        
        #tracking-canvas {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            transform: scaleX(-1);
        }
        
        .tracking-label {
            position: absolute;
            top: 5px; left: 5px;
            background: rgba(0,0,0,0.7);
            color: #00ffcc;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 10px;
            font-family: 'Orbitron', monospace;
        }
        
        #game-canvas, #laser-canvas {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
        }
        
        #game-canvas { z-index: 2; }
        #laser-canvas { z-index: 4; }
        
        #hud {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 5;
            pointer-events: none;
        }
        
        .score-container {
            position: absolute;
            top: 15px; left: 15px;
            display: flex;
            gap: 10px;
        }
        
        .score-box {
            background: rgba(0,0,0,0.7);
            border: 1px solid #ff3366;
            border-radius: 8px;
            padding: 8px 16px;
            text-align: center;
        }
        
        .score-label { font-size: 10px; color: #ff9999; text-transform: uppercase; }
        .score-value { font-family: 'Orbitron', monospace; font-size: 24px; font-weight: 900; color: #fff; text-shadow: 0 0 10px #ff3366; }
        .combo-box { border-color: #00ffcc; }
        .combo-box .score-value { color: #00ffcc; text-shadow: 0 0 10px #00ffcc; }
        
        .help-btn {
            position: absolute;
            top: 15px; right: 15px;
            width: 40px; height: 40px;
            background: rgba(0,0,0,0.7);
            border: 2px solid #ffcc00;
            border-radius: 50%;
            color: #ffcc00;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            pointer-events: auto;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .help-tooltip {
            position: absolute;
            top: 60px; right: 15px;
            background: rgba(0,0,0,0.95);
            border: 1px solid #ffcc00;
            border-radius: 12px;
            padding: 15px;
            max-width: 280px;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s;
            pointer-events: none;
        }
        
        .help-btn:hover + .help-tooltip { opacity: 1; visibility: visible; }
        .help-tooltip h4 { font-family: 'Orbitron', monospace; font-size: 12px; color: #ffcc00; margin-bottom: 10px; }
        .help-tooltip p { font-size: 12px; color: #ccc; line-height: 1.6; margin-bottom: 8px; }
        .help-tooltip .key { color: #00ffcc; font-weight: bold; }
        
        .gesture-indicator {
            position: absolute;
            bottom: 15px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.85);
            border: 2px solid #ffcc00;
            border-radius: 30px;
            padding: 10px 25px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .gesture-icon { font-size: 28px; }
        .gesture-text { font-family: 'Orbitron', monospace; font-size: 14px; color: #ffcc00; text-transform: uppercase; }
        .gesture-indicator.aiming { border-color: #00ffcc; }
        .gesture-indicator.aiming .gesture-text { color: #00ffcc; }
        .gesture-indicator.firing { border-color: #ff3366; animation: fireFlash 0.15s; }
        .gesture-indicator.firing .gesture-text { color: #ff3366; }
        
        @keyframes fireFlash { 0% { transform: translateX(-50%) scale(1.2); } 100% { transform: translateX(-50%) scale(1); } }
        
        .vfx-text {
            position: fixed;
            font-family: 'Orbitron', monospace;
            font-weight: 900;
            font-size: 42px;
            pointer-events: none;
            z-index: 100;
            animation: vfxFloat 0.8s ease-out forwards;
            text-shadow: 0 0 20px currentColor;
        }
        
        .vfx-hit { color: #00ffcc; }
        .vfx-miss { color: #ff3366; }
        
        @keyframes vfxFloat {
            0% { opacity: 1; transform: translate(-50%, -50%) scale(0.5); }
            50% { opacity: 1; transform: translate(-50%, -100%) scale(1.2); }
            100% { opacity: 0; transform: translate(-50%, -150%) scale(1); }
        }
        
        .crosshair {
            position: fixed;
            width: 70px; height: 70px;
            pointer-events: none;
            z-index: 50;
            transform: translate(-50%, -50%);
        }
        
        .crosshair-ring {
            position: absolute;
            width: 100%; height: 100%;
            border: 3px solid #ff3366;
            border-radius: 50%;
            animation: crosshairPulse 1s infinite;
        }
        
        .crosshair-ring::before, .crosshair-ring::after {
            content: '';
            position: absolute;
            background: #ff3366;
            width: 15px; height: 3px;
            top: 50%;
            transform: translateY(-50%);
        }
        
        .crosshair-ring::before { left: -20px; }
        .crosshair-ring::after { right: -20px; }
        .crosshair-ring.locked { border-color: #00ffcc; animation: crosshairLocked 0.25s infinite; }
        .crosshair-ring.locked::before, .crosshair-ring.locked::after { background: #00ffcc; }
        
        .crosshair-dot {
            position: absolute;
            top: 50%; left: 50%;
            width: 8px; height: 8px;
            background: #ff3366;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 15px #ff3366;
        }
        
        .crosshair-dot.locked { background: #00ffcc; box-shadow: 0 0 15px #00ffcc; }
        
        @keyframes crosshairPulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.1); opacity: 0.7; } }
        @keyframes crosshairLocked { 0%, 100% { transform: scale(1); } 50% { transform: scale(0.9); } }
        
        .shoot-hint {
            position: fixed;
            bottom: 70px;
            left: 50%;
            transform: translateX(-50%);
            color: #ffcc00;
            font-size: 13px;
            font-family: 'Orbitron', monospace;
            background: rgba(0,0,0,0.8);
            padding: 8px 16px;
            border-radius: 20px;
            border: 1px solid #ffcc00;
            display: none;
        }
        
        .shoot-hint.visible { display: block; animation: hintPulse 1.5s infinite; }
        
        @keyframes hintPulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.6; } }
        
        /* Speed meter */
        .speed-meter {
            position: fixed;
            bottom: 110px;
            left: 50%;
            transform: translateX(-50%);
            width: 200px;
            height: 12px;
            background: rgba(0,0,0,0.7);
            border-radius: 6px;
            border: 1px solid #666;
            overflow: hidden;
            display: none;
        }
        
        .speed-meter.visible { display: block; }
        
        .speed-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #00ffcc, #ffcc00, #ff3366);
            border-radius: 6px;
            transition: width 0.05s;
        }
        
        .speed-threshold {
            position: absolute;
            left: 80%;
            top: 0;
            bottom: 0;
            width: 2px;
            background: #fff;
        }
        
        .speed-label {
            position: absolute;
            top: -18px;
            left: 0;
            right: 0;
            text-align: center;
            font-size: 10px;
            color: #999;
            font-family: 'Orbitron', monospace;
        }
        
        /* Jerk indicator */
        .jerk-flash {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: radial-gradient(circle at center, rgba(255,51,102,0.4) 0%, transparent 60%);
            pointer-events: none;
            z-index: 99;
            opacity: 0;
            transition: opacity 0.05s;
        }
        
        .jerk-flash.active { opacity: 1; }
    </style>
</head>
<body>
    <div id="loading-overlay">
        <div class="loader-container">
            <div class="loader-ring"></div>
            <div class="loader-ring"></div>
            <div class="loader-ring"></div>
            <div class="loader-icon">üî´</div>
        </div>
        <div class="loading-title">AR –®—É—Ç–µ—Ä</div>
        <div class="loading-status" id="loading-status">–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è...</div>
        <div class="loading-bar-container">
            <div class="loading-bar" id="loading-bar"></div>
        </div>
    </div>

    <div id="background">
        <div class="bg-stars"></div>
        <div class="bg-nebula"></div>
    </div>

    <div id="camera-pip">
        <video id="webcam" autoplay playsinline></video>
        <canvas id="tracking-canvas"></canvas>
        <div class="tracking-label">–¢—Ä–µ–∫–∏–Ω–≥</div>
    </div>

    <canvas id="game-canvas"></canvas>
    <canvas id="laser-canvas"></canvas>
    
    <div class="jerk-flash" id="jerk-flash"></div>
    
    <div class="speed-meter" id="speed-meter">
        <div class="speed-label">–°–∫–æ—Ä–æ—Å—Ç—å –¥–≤–∏–∂–µ–Ω–∏—è</div>
        <div class="speed-bar" id="speed-bar"></div>
        <div class="speed-threshold"></div>
    </div>
    
    <div class="shoot-hint" id="shoot-hint">‚Üó –†–µ–∑–∫–æ –æ—Ç–¥—ë—Ä–Ω–∏ –Ω–∞–∑–∞–¥ + –≤–≤–µ—Ä—Ö!</div>

    <div id="hud">
        <div class="score-container">
            <div class="score-box">
                <div class="score-label">–û—á–∫–∏</div>
                <div class="score-value" id="score">0</div>
            </div>
            <div class="score-box combo-box">
                <div class="score-label">–ö–æ–º–±–æ</div>
                <div class="score-value" id="combo">x1</div>
            </div>
        </div>
        
        <button class="help-btn">?</button>
        <div class="help-tooltip">
            <h4>–ö–∞–∫ –∏–≥—Ä–∞—Ç—å</h4>
            <p>üëÜ <span class="key">–ü–∏—Å—Ç–æ–ª–µ—Ç:</span> –í—ã—Ç—è–Ω–∏ —É–∫–∞–∑–∞—Ç–µ–ª—å–Ω—ã–π –ø–∞–ª–µ—Ü</p>
            <p>üéØ <span class="key">–ü—Ä–∏—Ü–µ–ª:</span> –î–≤–∏–≥–∞–π —Ä—É–∫–æ–π</p>
            <p>üí• <span class="key">–í—ã—Å—Ç—Ä–µ–ª:</span> –†–µ–∑–∫–æ –æ—Ç–¥—ë—Ä–Ω–∏ —Ä—É–∫—É –ù–ê–ó–ê–î (–∫ —Å–µ–±–µ) –∏ –í–í–ï–†–• –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ!</p>
            <p style="color:#ff9966; font-size:11px;">‚ö†Ô∏è –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–µ –¥–≤–∏–∂–µ–Ω–∏—è –Ω–µ —Å—á–∏—Ç–∞—é—Ç—Å—è</p>
        </div>
        
        <div class="gesture-indicator" id="gesture-indicator">
            <span class="gesture-icon" id="gesture-icon">‚úã</span>
            <span class="gesture-text" id="gesture-text">–ü–æ–∫–∞–∂–∏ —Ä—É–∫—É</span>
        </div>
    </div>

    <div class="crosshair" id="crosshair" style="display: none;">
        <div class="crosshair-ring" id="crosshair-ring"></div>
        <div class="crosshair-dot" id="crosshair-dot"></div>
    </div>

    <script src="https://unpkg.com/three@0.150.1/build/three.min.js"></script>
    <script src="https://unpkg.com/@mediapipe/hands@0.4.1646424915/hands.js"></script>
    <script src="https://unpkg.com/@mediapipe/camera_utils@0.3.1640029074/camera_utils.js"></script>

    <script>
        const CONFIG = {
            DISC_COUNT: 4,
            DISC_SPEED: 0.012,
            DISC_SIZE: 0.5,
            AIM_ASSIST_RADIUS: 150,
            AIM_ASSIST_STRENGTH: 0.5,
            DETECTION_INTERVAL: 20,     // –ë—ã—Å—Ç—Ä–µ–µ –¥–µ—Ç–µ–∫—Ü–∏—è
            SHOOT_COOLDOWN: 350,
            HIT_RADIUS: 100,
            SMOOTHING: 0.5,
            // Recoil detection - –±–æ–ª–µ–µ —á—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π
            JERK_SPEED_THRESHOLD: 0.25, // –û–±—â–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å
            BACK_THRESHOLD: 0.08,       // –ü–æ—Ä–æ–≥ –¥–ª—è "–Ω–∞–∑–∞–¥" (—É–º–µ–Ω—å—à–µ–Ω)
            UP_THRESHOLD: 0.08,         // –ü–æ—Ä–æ–≥ –¥–ª—è "–≤–≤–µ—Ä—Ö"
            JERK_COOLDOWN: 350,
        };

        // ============================================
        // RECOIL DETECTOR - –û–ø—Ä–µ–¥–µ–ª—è–µ—Ç –æ—Ç–¥—ë—Ä–≥–∏–≤–∞–Ω–∏–µ –Ω–∞–∑–∞–¥-–≤–≤–µ—Ä—Ö
        // ============================================
        class JerkDetector {
            constructor() {
                this.history = [];
                this.maxHistory = 10;
                this.lastJerkTime = 0;
            }

            addPosition(x, y) {
                const now = Date.now();
                this.history.push({ x, y, time: now });
                if (this.history.length > this.maxHistory) {
                    this.history.shift();
                }
            }

            // –°–∫–æ—Ä–æ—Å—Ç—å –∑–∞ –Ω–µ—Å–∫–æ–ª—å–∫–æ –ø–æ—Å–ª–µ–¥–Ω–∏—Ö –∫–∞–¥—Ä–æ–≤ (–±–æ–ª–µ–µ —Å—Ç–∞–±–∏–ª—å–Ω–æ)
            getMovement() {
                if (this.history.length < 4) return { dx: 0, dy: 0, speed: 0 };
                
                const len = this.history.length;
                // –ë–µ—Ä—ë–º –¥–≤–∏–∂–µ–Ω–∏–µ –∑–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 3-4 –∫–∞–¥—Ä–∞
                const p1 = this.history[len - 4];
                const p2 = this.history[len - 1];
                const dt = (p2.time - p1.time) / 1000;
                if (dt <= 0) return { dx: 0, dy: 0, speed: 0 };
                
                const dx = (p2.x - p1.x) / dt;  // –°–∫–æ—Ä–æ—Å—Ç—å –ø–æ X
                const dy = (p2.y - p1.y) / dt;  // –°–∫–æ—Ä–æ—Å—Ç—å –ø–æ Y
                const speed = Math.sqrt(dx * dx + dy * dy);
                
                return { dx, dy, speed };
            }

            // –¢–µ–∫—É—â–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å –¥–ª—è –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏
            getCurrentSpeed() {
                return this.getMovement().speed;
            }

            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –æ—Ç–¥—ë—Ä–≥–∏–≤–∞–Ω–∏—è: –ù–ê–ó–ê–î (–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é) + –í–í–ï–†–•
            checkJerk() {
                const now = Date.now();
                
                // –ö—É–ª–¥–∞—É–Ω –ø–æ—Å–ª–µ –≤—ã—Å—Ç—Ä–µ–ª–∞
                if (now - this.lastJerkTime < CONFIG.JERK_COOLDOWN) {
                    return { detected: false, speed: 0, backSpeed: 0, upSpeed: 0 };
                }

                const mov = this.getMovement();
                
                // –í –Ω–æ—Ä–º–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã—Ö –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞—Ö MediaPipe:
                // X: 0 = –ø—Ä–∞–≤—ã–π –∫—Ä–∞–π –∫–∞–º–µ—Ä—ã, 1 = –ª–µ–≤—ã–π –∫—Ä–∞–π (–∑–µ—Ä–∫–∞–ª—å–Ω–æ)
                // Y: 0 = –≤–µ—Ä—Ö, 1 = –Ω–∏–∑
                // 
                // –ö–æ–≥–¥–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –æ—Ç–¥—ë—Ä–≥–∏–≤–∞–µ—Ç —Ä—É–∫—É –ù–ê–ó–ê–î (–∫ —Å–µ–±–µ):
                // - –í —Ä–µ–∞–ª—å–Ω–æ—Å—Ç–∏ —Ä—É–∫–∞ —É—Ö–æ–¥–∏—Ç –æ—Ç –∫–∞–º–µ—Ä—ã
                // - X –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞ —É–≤–µ–ª–∏—á–∏–≤–∞–µ—Ç—Å—è (–¥–≤–∏–∂–µ–Ω–∏–µ –≤–ø—Ä–∞–≤–æ –≤ —Å—ã—Ä—ã—Ö –¥–∞–Ω–Ω—ã—Ö)
                // - dx > 0 = –¥–≤–∏–∂–µ–Ω–∏–µ –Ω–∞–∑–∞–¥
                //
                // –ö–æ–≥–¥–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –¥–≤–∏–≥–∞–µ—Ç —Ä—É–∫—É –í–í–ï–†–•:
                // - Y –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞ —É–º–µ–Ω—å—à–∞–µ—Ç—Å—è
                // - dy < 0 = –¥–≤–∏–∂–µ–Ω–∏–µ –≤–≤–µ—Ä—Ö
                
                const backSpeed = mov.dx;     // –ü–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–π = –Ω–∞–∑–∞–¥ (–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é)
                const upSpeed = -mov.dy;      // –ü–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–π = –≤–≤–µ—Ä—Ö
                
                // –¢—Ä–µ–±—É–µ–º –¥–≤–∏–∂–µ–Ω–∏–µ –ò –Ω–∞–∑–∞–¥ –ò –≤–≤–µ—Ä—Ö –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ
                const isMovingBack = backSpeed > CONFIG.BACK_THRESHOLD;
                const isMovingUp = upSpeed > CONFIG.UP_THRESHOLD;
                const totalSpeed = mov.speed;
                
                // –û—Ç–¥—ë—Ä–≥–∏–≤–∞–Ω–∏–µ = –±—ã—Å—Ç—Ä–æ + –Ω–∞–∑–∞–¥ + –≤–≤–µ—Ä—Ö
                const isRecoil = totalSpeed > CONFIG.JERK_SPEED_THRESHOLD && 
                                 isMovingBack && isMovingUp;

                if (isRecoil) {
                    this.lastJerkTime = now;
                    console.log(`‚úÖ RECOIL: back=${backSpeed.toFixed(2)}, up=${upSpeed.toFixed(2)}, total=${totalSpeed.toFixed(2)}`);
                    return { 
                        detected: true, 
                        speed: totalSpeed,
                        backSpeed: backSpeed,
                        upSpeed: upSpeed
                    };
                }

                return { 
                    detected: false, 
                    speed: totalSpeed,
                    backSpeed: backSpeed,
                    upSpeed: upSpeed
                };
            }

            clear() {
                this.history = [];
            }
        }

        // ============================================
        // AUDIO
        // ============================================
        class AudioSystem {
            constructor() { this.ctx = null; }
            init() {
                if (this.ctx) return;
                try { this.ctx = new (window.AudioContext || window.webkitAudioContext)(); } catch(e) {}
            }
            playShoot() {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.frequency.setValueAtTime(900, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(150, this.ctx.currentTime + 0.12);
                gain.gain.setValueAtTime(0.4, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.12);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.12);
            }
            playHit() {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sawtooth';
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.frequency.setValueAtTime(500, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(50, this.ctx.currentTime + 0.2);
                gain.gain.setValueAtTime(0.5, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.2);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.2);
            }
            playMiss() {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.frequency.setValueAtTime(180, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(80, this.ctx.currentTime + 0.2);
                gain.gain.setValueAtTime(0.25, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.2);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.2);
            }
        }

        // ============================================
        // GAME STATE
        // ============================================
        const gameState = {
            score: 0,
            combo: 1,
            lastHitTime: 0,
            lastShotTime: 0,
            aimPosition: { x: window.innerWidth / 2, y: window.innerHeight / 2 },
            smoothedAimPosition: { x: window.innerWidth / 2, y: window.innerHeight / 2 },
            isPistolGesture: false,
            handVisible: false,
            lockedTarget: null,
            lastHandTime: 0,
            currentLandmarks: null,
        };

        const jerkDetector = new JerkDetector();

        // DOM
        const loadingOverlay = document.getElementById('loading-overlay');
        const loadingStatus = document.getElementById('loading-status');
        const loadingBar = document.getElementById('loading-bar');
        const webcam = document.getElementById('webcam');
        const trackingCanvas = document.getElementById('tracking-canvas');
        const trackingCtx = trackingCanvas.getContext('2d');
        const gameCanvas = document.getElementById('game-canvas');
        const laserCanvas = document.getElementById('laser-canvas');
        const crosshair = document.getElementById('crosshair');
        const crosshairRing = document.getElementById('crosshair-ring');
        const crosshairDot = document.getElementById('crosshair-dot');
        const scoreDisplay = document.getElementById('score');
        const comboDisplay = document.getElementById('combo');
        const gestureIndicator = document.getElementById('gesture-indicator');
        const gestureIcon = document.getElementById('gesture-icon');
        const gestureText = document.getElementById('gesture-text');
        const shootHint = document.getElementById('shoot-hint');
        const jerkFlash = document.getElementById('jerk-flash');
        const speedMeter = document.getElementById('speed-meter');
        const speedBar = document.getElementById('speed-bar');

        // THREE.JS
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 5;

        const renderer = new THREE.WebGLRenderer({ canvas: gameCanvas, alpha: true, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

        const laserCtx = laserCanvas.getContext('2d');
        laserCanvas.width = window.innerWidth;
        laserCanvas.height = window.innerHeight;

        // –û—Å–≤–µ—â–µ–Ω–∏–µ –¥–ª—è –∫—Ä–∞—Å–∏–≤—ã—Ö –º–∏—à–µ–Ω–µ–π
        scene.add(new THREE.AmbientLight(0xffffff, 0.4));
        
        const mainLight = new THREE.PointLight(0xffffff, 1.2, 100);
        mainLight.position.set(0, 0, 8);
        scene.add(mainLight);
        
        const redLight = new THREE.PointLight(0xff3366, 0.8, 50);
        redLight.position.set(-4, 3, 5);
        scene.add(redLight);
        
        const blueLight = new THREE.PointLight(0x00ffcc, 0.6, 50);
        blueLight.position.set(4, -3, 5);
        scene.add(blueLight);

        // ============================================
        // HAND TRACKING VISUALIZATION
        // ============================================
        const HAND_CONNECTIONS = [
            [0,1],[1,2],[2,3],[3,4],[0,5],[5,6],[6,7],[7,8],
            [0,9],[9,10],[10,11],[11,12],[0,13],[13,14],[14,15],[15,16],
            [0,17],[17,18],[18,19],[19,20],[5,9],[9,13],[13,17]
        ];

        function drawHandTracking(landmarks) {
            trackingCtx.clearRect(0, 0, trackingCanvas.width, trackingCanvas.height);
            if (!landmarks || landmarks.length === 0) return;

            const hand = landmarks[0];
            const w = trackingCanvas.width;
            const h = trackingCanvas.height;

            // Connections
            trackingCtx.strokeStyle = '#00ffcc';
            trackingCtx.lineWidth = 2;
            for (const [start, end] of HAND_CONNECTIONS) {
                trackingCtx.beginPath();
                trackingCtx.moveTo(hand[start].x * w, hand[start].y * h);
                trackingCtx.lineTo(hand[end].x * w, hand[end].y * h);
                trackingCtx.stroke();
            }

            // Joints
            for (let i = 0; i < hand.length; i++) {
                const x = hand[i].x * w;
                const y = hand[i].y * h;
                
                if (i === 8) { // Index tip - highlighted
                    const recoil = jerkDetector.checkJerk();
                    const speed = recoil.speed;
                    const backSpeed = recoil.backSpeed || 0;
                    const upSpeed = recoil.upSpeed || 0;
                    
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø—Ä–∞–≤–∏–ª—å–Ω–æ–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
                    const isBack = backSpeed > CONFIG.BACK_THRESHOLD;
                    const isUp = upSpeed > CONFIG.UP_THRESHOLD;
                    const isRecoilDirection = isBack && isUp;
                    const isFastEnough = speed > CONFIG.JERK_SPEED_THRESHOLD;
                    
                    // Outer glow
                    const glowSize = 15 + Math.min(speed * 60, 35);
                    trackingCtx.beginPath();
                    trackingCtx.arc(x, y, glowSize, 0, Math.PI * 2);
                    
                    if (isFastEnough && isRecoilDirection) {
                        trackingCtx.fillStyle = 'rgba(255, 51, 102, 0.6)';
                    } else if (isRecoilDirection) {
                        trackingCtx.fillStyle = 'rgba(255, 204, 0, 0.4)';
                    } else {
                        trackingCtx.fillStyle = 'rgba(0, 255, 204, 0.3)';
                    }
                    trackingCtx.fill();
                    
                    // Inner circle
                    trackingCtx.beginPath();
                    trackingCtx.arc(x, y, 10, 0, Math.PI * 2);
                    trackingCtx.fillStyle = isRecoilDirection ? '#ffcc00' : '#00ffcc';
                    if (isFastEnough && isRecoilDirection) {
                        trackingCtx.fillStyle = '#ff3366';
                    }
                    trackingCtx.fill();
                    
                    // Direction arrow - –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç –Ω—É–∂–Ω–æ–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
                    trackingCtx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
                    trackingCtx.lineWidth = 2;
                    trackingCtx.beginPath();
                    trackingCtx.moveTo(x, y);
                    // –°—Ç—Ä–µ–ª–∫–∞ –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –Ω–∞–∑–∞–¥-–≤–≤–µ—Ä—Ö
                    trackingCtx.lineTo(x + 25, y - 20);
                    trackingCtx.stroke();
                    
                    // –ù–∞–∫–æ–Ω–µ—á–Ω–∏–∫ —Å—Ç—Ä–µ–ª–∫–∏
                    trackingCtx.beginPath();
                    trackingCtx.moveTo(x + 25, y - 20);
                    trackingCtx.lineTo(x + 18, y - 18);
                    trackingCtx.moveTo(x + 25, y - 20);
                    trackingCtx.lineTo(x + 23, y - 13);
                    trackingCtx.stroke();
                } else {
                    trackingCtx.beginPath();
                    trackingCtx.arc(x, y, 4, 0, Math.PI * 2);
                    trackingCtx.fillStyle = i < 5 ? '#ffcc00' : '#00ffcc';
                    trackingCtx.fill();
                }
            }
        }

        // ============================================
        // IMPROVED DISC - –ö—Ä–∞—Å–∏–≤—ã–µ –º–∏—à–µ–Ω–∏ —Å —Ñ–∏–∑–∏–∫–æ–π
        // ============================================
        class Disc {
            constructor(index) {
                this.index = index;
                this.radius = CONFIG.DISC_SIZE;
                this.velocity = new THREE.Vector3();
                this.createMesh();
                this.spawn();
            }
            
            createMesh() {
                this.hue = Math.random();
                
                // –û—Å–Ω–æ–≤–Ω–∞—è –≥—Ä—É–ø–ø–∞
                this.group = new THREE.Group();
                
                // –û—Å–Ω–æ–≤–Ω–æ–π –¥–∏—Å–∫ - –±–æ–ª–µ–µ –¥–µ—Ç–∞–ª—å–Ω—ã–π
                const discGeo = new THREE.CylinderGeometry(this.radius, this.radius, 0.12, 48);
                const discMat = new THREE.MeshStandardMaterial({
                    color: new THREE.Color().setHSL(this.hue, 0.85, 0.5),
                    metalness: 0.9,
                    roughness: 0.15,
                    emissive: new THREE.Color().setHSL(this.hue, 0.9, 0.35),
                    emissiveIntensity: 0.5,
                });
                this.disc = new THREE.Mesh(discGeo, discMat);
                this.disc.rotation.x = Math.PI / 2;
                this.group.add(this.disc);
                
                // –í–Ω–µ—à–Ω–µ–µ –∫–æ–ª—å—Ü–æ (–æ–±–æ–¥)
                const rimGeo = new THREE.TorusGeometry(this.radius, 0.04, 16, 48);
                const rimMat = new THREE.MeshStandardMaterial({ 
                    color: new THREE.Color().setHSL(this.hue, 1, 0.7),
                    metalness: 1,
                    roughness: 0.1,
                    emissive: new THREE.Color().setHSL(this.hue, 1, 0.5),
                    emissiveIntensity: 0.8,
                });
                this.rim = new THREE.Mesh(rimGeo, rimMat);
                this.group.add(this.rim);
                
                // –í–Ω—É—Ç—Ä–µ–Ω–Ω–µ–µ —Å–≤–µ—á–µ–Ω–∏–µ (—Ü–µ–Ω—Ç—Ä)
                const coreGeo = new THREE.CircleGeometry(this.radius * 0.4, 32);
                const coreMat = new THREE.MeshBasicMaterial({
                    color: new THREE.Color().setHSL(this.hue, 1, 0.8),
                    transparent: true,
                    opacity: 0.9,
                    side: THREE.DoubleSide,
                });
                this.core = new THREE.Mesh(coreGeo, coreMat);
                this.core.position.z = 0.07;
                this.group.add(this.core);
                
                // –î–µ–∫–æ—Ä–∞—Ç–∏–≤–Ω—ã–µ –∫–æ–ª—å—Ü–∞
                const ring1Geo = new THREE.TorusGeometry(this.radius * 0.6, 0.015, 8, 32);
                const ring1Mat = new THREE.MeshBasicMaterial({
                    color: new THREE.Color().setHSL((this.hue + 0.1) % 1, 1, 0.6),
                    transparent: true,
                    opacity: 0.7,
                });
                this.ring1 = new THREE.Mesh(ring1Geo, ring1Mat);
                this.ring1.position.z = 0.065;
                this.group.add(this.ring1);
                
                // –¢–æ—á–∫–∞ –≤ —Ü–µ–Ω—Ç—Ä–µ
                const dotGeo = new THREE.CircleGeometry(0.08, 16);
                const dotMat = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.95,
                });
                this.dot = new THREE.Mesh(dotGeo, dotMat);
                this.dot.position.z = 0.075;
                this.group.add(this.dot);
                
                // Mesh reference –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
                this.mesh = this.group;
                scene.add(this.group);
            }
            
            spawn() {
                // –í—ã–±–∏—Ä–∞–µ–º —Å–ª—É—á–∞–π–Ω—ã–π –∫—Ä–∞–π
                const edge = Math.floor(Math.random() * 4);
                const spread = 5.5;
                
                switch(edge) {
                    case 0: // –°–≤–µ—Ä—Ö—É
                        this.group.position.set((Math.random()-0.5)*spread*1.8, spread, 0);
                        break;
                    case 1: // –°–Ω–∏–∑—É
                        this.group.position.set((Math.random()-0.5)*spread*1.8, -spread, 0);
                        break;
                    case 2: // –°–ª–µ–≤–∞
                        this.group.position.set(-spread, (Math.random()-0.5)*spread*1.8, 0);
                        break;
                    case 3: // –°–ø—Ä–∞–≤–∞
                        this.group.position.set(spread, (Math.random()-0.5)*spread*1.8, 0);
                        break;
                }
                
                // –¶–µ–ª—å - —Ü–µ–Ω—Ç—Ä —Å –Ω–µ–±–æ–ª—å—à–∏–º –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–µ–º
                const targetX = (Math.random() - 0.5) * 2;
                const targetY = (Math.random() - 0.5) * 2;
                
                // –ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∏ —Å–∫–æ—Ä–æ—Å—Ç—å
                const dir = new THREE.Vector3(
                    targetX - this.group.position.x,
                    targetY - this.group.position.y,
                    0
                ).normalize();
                
                this.baseSpeed = CONFIG.DISC_SPEED * (0.7 + Math.random() * 0.5);
                this.velocity.copy(dir).multiplyScalar(this.baseSpeed);
                
                // –í—Ä–∞—â–µ–Ω–∏–µ
                this.rotSpeed = (Math.random() - 0.5) * 0.12;
                this.wobblePhase = Math.random() * Math.PI * 2;
                this.wobbleSpeed = 0.03 + Math.random() * 0.02;
                
                // –ü—É–ª—å—Å–∞—Ü–∏—è
                this.pulsePhase = Math.random() * Math.PI * 2;
                
                this.alive = true;
            }
            
            update(allDiscs) {
                if (!this.alive) return;
                
                // –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–∑–∏—Ü–∏—é
                this.group.position.add(this.velocity);
                
                // –§–∏–∑–∏–∫–∞ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–π —Å –¥—Ä—É–≥–∏–º–∏ –¥–∏—Å–∫–∞–º–∏
                for (const other of allDiscs) {
                    if (other === this || !other.alive) continue;
                    
                    const dx = other.group.position.x - this.group.position.x;
                    const dy = other.group.position.y - this.group.position.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const minDist = this.radius + other.radius + 0.3; // –ú–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ
                    
                    if (dist < minDist && dist > 0.01) {
                        // –í—ã—á–∏—Å–ª—è–µ–º —Å–∏–ª—É –æ—Ç—Ç–∞–ª–∫–∏–≤–∞–Ω–∏—è
                        const overlap = minDist - dist;
                        const nx = dx / dist;
                        const ny = dy / dist;
                        
                        // –û—Ç—Ç–∞–ª–∫–∏–≤–∞–µ–º –¥—Ä—É–≥ –æ—Ç –¥—Ä—É–≥–∞
                        const pushForce = overlap * 0.3;
                        this.group.position.x -= nx * pushForce;
                        this.group.position.y -= ny * pushForce;
                        other.group.position.x += nx * pushForce;
                        other.group.position.y += ny * pushForce;
                        
                        // –ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä—É–µ–º —Å–∫–æ—Ä–æ—Å—Ç–∏ (—É–ø—Ä—É–≥–æ–µ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–µ)
                        const dvx = this.velocity.x - other.velocity.x;
                        const dvy = this.velocity.y - other.velocity.y;
                        const dvDotN = dvx * nx + dvy * ny;
                        
                        if (dvDotN > 0) {
                            const bounce = 0.5;
                            this.velocity.x -= bounce * dvDotN * nx;
                            this.velocity.y -= bounce * dvDotN * ny;
                            other.velocity.x += bounce * dvDotN * nx;
                            other.velocity.y += bounce * dvDotN * ny;
                        }
                    }
                }
                
                // –í–æ–∑–≤—Ä–∞—â–∞–µ–º—Å—è –∫ –±–∞–∑–æ–≤–æ–π —Å–∫–æ—Ä–æ—Å—Ç–∏
                const currentSpeed = this.velocity.length();
                if (currentSpeed > 0.001) {
                    const targetSpeed = this.baseSpeed;
                    const speedDiff = targetSpeed - currentSpeed;
                    this.velocity.normalize().multiplyScalar(currentSpeed + speedDiff * 0.02);
                }
                
                // –ü–æ–∫–∞—á–∏–≤–∞–Ω–∏–µ
                this.wobblePhase += this.wobbleSpeed;
                this.group.rotation.x = Math.sin(this.wobblePhase) * 0.15;
                this.group.rotation.y = Math.cos(this.wobblePhase * 0.7) * 0.1;
                
                // –í—Ä–∞—â–µ–Ω–∏–µ –¥–∏—Å–∫–∞
                this.disc.rotation.z += this.rotSpeed;
                this.ring1.rotation.z -= this.rotSpeed * 1.5;
                
                // –ü—É–ª—å—Å–∞—Ü–∏—è —Å–≤–µ—á–µ–Ω–∏—è
                this.pulsePhase += 0.05;
                const pulse = 0.8 + Math.sin(this.pulsePhase) * 0.2;
                this.core.material.opacity = 0.7 + Math.sin(this.pulsePhase) * 0.3;
                this.rim.material.emissiveIntensity = 0.5 + Math.sin(this.pulsePhase) * 0.3;
                
                // –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤—ã—Ö–æ–¥–∞ –∑–∞ –≥—Ä–∞–Ω–∏—Ü—ã
                if (Math.abs(this.group.position.x) > 7 || Math.abs(this.group.position.y) > 7) {
                    this.spawn();
                }
            }
            
            getScreenPos() {
                const v = this.group.position.clone();
                v.project(camera);
                return { 
                    x: (v.x * 0.5 + 0.5) * window.innerWidth, 
                    y: (-v.y * 0.5 + 0.5) * window.innerHeight 
                };
            }
            
            respawn() {
                // –ù–æ–≤—ã–π —Ü–≤–µ—Ç
                this.hue = Math.random();
                
                this.disc.material.color.setHSL(this.hue, 0.85, 0.5);
                this.disc.material.emissive.setHSL(this.hue, 0.9, 0.35);
                this.rim.material.color.setHSL(this.hue, 1, 0.7);
                this.rim.material.emissive.setHSL(this.hue, 1, 0.5);
                this.core.material.color.setHSL(this.hue, 1, 0.8);
                this.ring1.material.color.setHSL((this.hue + 0.1) % 1, 1, 0.6);
                
                this.spawn();
            }
        }

        // ============================================
        // PARTICLES - –£–ª—É—á—à–µ–Ω–Ω—ã–µ —á–∞—Å—Ç–∏—Ü—ã
        // ============================================
        class ParticleSystem {
            constructor() { 
                this.particles = []; 
            }
            
            emit(x, y, z, count = 30, hue = null) {
                // –û—Å–∫–æ–ª–∫–∏ –¥–∏—Å–∫–∞
                for (let i = 0; i < count; i++) {
                    const isLarge = i < 8;
                    const size = isLarge ? 0.06 + Math.random() * 0.04 : 0.02 + Math.random() * 0.03;
                    
                    const geo = isLarge 
                        ? new THREE.BoxGeometry(size, size, size * 0.3)
                        : new THREE.SphereGeometry(size, 6, 6);
                    
                    const particleHue = hue !== null ? hue : Math.random();
                    const mat = new THREE.MeshBasicMaterial({ 
                        color: new THREE.Color().setHSL(particleHue, 1, 0.5 + Math.random() * 0.3),
                        transparent: true,
                        opacity: 1,
                    });
                    
                    const p = new THREE.Mesh(geo, mat);
                    p.position.set(x, y, z);
                    
                    // –†–∞–∑–ª–µ—Ç–∞—é—Ç—Å—è –≤–æ –≤—Å–µ —Å—Ç–æ—Ä–æ–Ω—ã
                    const angle = Math.random() * Math.PI * 2;
                    const upward = 0.1 + Math.random() * 0.15;
                    const speed = 0.15 + Math.random() * 0.2;
                    
                    p.velocity = new THREE.Vector3(
                        Math.cos(angle) * speed,
                        Math.sin(angle) * speed + upward,
                        (Math.random() - 0.5) * 0.1
                    );
                    
                    p.rotation.set(
                        Math.random() * Math.PI,
                        Math.random() * Math.PI,
                        Math.random() * Math.PI
                    );
                    p.rotVel = new THREE.Vector3(
                        (Math.random() - 0.5) * 0.3,
                        (Math.random() - 0.5) * 0.3,
                        (Math.random() - 0.5) * 0.3
                    );
                    
                    p.life = 1;
                    p.decay = 0.015 + Math.random() * 0.015;
                    p.isLarge = isLarge;
                    
                    scene.add(p);
                    this.particles.push(p);
                }
                
                // –ò—Å–∫—Ä—ã
                for (let i = 0; i < 15; i++) {
                    const geo = new THREE.SphereGeometry(0.015, 4, 4);
                    const mat = new THREE.MeshBasicMaterial({ 
                        color: 0xffffff,
                        transparent: true,
                        opacity: 1,
                    });
                    
                    const p = new THREE.Mesh(geo, mat);
                    p.position.set(x, y, z);
                    
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 0.2 + Math.random() * 0.3;
                    p.velocity = new THREE.Vector3(
                        Math.cos(angle) * speed,
                        Math.sin(angle) * speed,
                        (Math.random() - 0.5) * 0.2
                    );
                    
                    p.life = 1;
                    p.decay = 0.04 + Math.random() * 0.03;
                    p.isSpark = true;
                    
                    scene.add(p);
                    this.particles.push(p);
                }
            }
            
            update() {
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const p = this.particles[i];
                    
                    p.position.add(p.velocity);
                    p.velocity.y -= 0.008; // –ì—Ä–∞–≤–∏—Ç–∞—Ü–∏—è
                    p.velocity.multiplyScalar(0.98); // –°–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏–µ –≤–æ–∑–¥—É—Ö–∞
                    
                    p.life -= p.decay;
                    p.material.opacity = p.life;
                    
                    if (p.rotVel) {
                        p.rotation.x += p.rotVel.x;
                        p.rotation.y += p.rotVel.y;
                        p.rotation.z += p.rotVel.z;
                    }
                    
                    if (!p.isSpark) {
                        p.scale.setScalar(0.5 + p.life * 0.5);
                    } else {
                        p.scale.setScalar(p.life);
                    }
                    
                    if (p.life <= 0) {
                        scene.remove(p);
                        p.geometry.dispose();
                        p.material.dispose();
                        this.particles.splice(i, 1);
                    }
                }
            }
        }

        const audio = new AudioSystem();
        const particles = new ParticleSystem();
        const discs = [];

        function showVFX(text, x, y, isHit) {
            const el = document.createElement('div');
            el.className = `vfx-text ${isHit ? 'vfx-hit' : 'vfx-miss'}`;
            el.textContent = text;
            el.style.left = x + 'px';
            el.style.top = y + 'px';
            document.body.appendChild(el);
            setTimeout(() => el.remove(), 800);
        }

        function detectPistolGesture(landmarks) {
            if (!landmarks || landmarks.length === 0) return false;
            const h = landmarks[0];
            
            // –£–∫–∞–∑–∞—Ç–µ–ª—å–Ω—ã–π –ø–∞–ª–µ—Ü –≤—ã—Ç—è–Ω—É—Ç (–∫–æ–Ω—á–∏–∫ –≤—ã—à–µ —Å—É—Å—Ç–∞–≤–∞)
            const indexExtended = h[8].y < h[6].y + 0.02;
            
            // –û—Å—Ç–∞–ª—å–Ω—ã–µ –ø–∞–ª—å—Ü—ã —Å–æ–≥–Ω—É—Ç—ã (–±–æ–ª–µ–µ –º—è–≥–∫–∏–µ –ø–æ—Ä–æ–≥–∏)
            const middleCurled = h[12].y > h[10].y - 0.08;
            const ringCurled = h[16].y > h[14].y - 0.08;
            const pinkyCurled = h[20].y > h[18].y - 0.08;
            
            // –î–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –µ—Å–ª–∏ —É–∫–∞–∑–∞—Ç–µ–ª—å–Ω—ã–π –≤—ã—Ç—è–Ω—É—Ç –∏ —Ö–æ—Ç—è –±—ã 1 –ø–∞–ª–µ—Ü —Å–æ–≥–Ω—É—Ç
            const curledCount = [middleCurled, ringCurled, pinkyCurled].filter(x=>x).length;
            return indexExtended && curledCount >= 1;
        }

        function applyAimAssist(rawX, rawY) {
            let ax = rawX, ay = rawY;
            let closest = CONFIG.AIM_ASSIST_RADIUS;
            let locked = null;
            for (const d of discs) {
                if (!d.alive) continue;
                const sp = d.getScreenPos();
                const dx = sp.x - rawX, dy = sp.y - rawY;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist < closest) {
                    closest = dist;
                    locked = d;
                    const pull = CONFIG.AIM_ASSIST_STRENGTH * (1 - dist/CONFIG.AIM_ASSIST_RADIUS);
                    ax = rawX + dx*pull;
                    ay = rawY + dy*pull;
                }
            }
            gameState.lockedTarget = locked;
            return { x: ax, y: ay };
        }

        function shoot() {
            const now = Date.now();
            if (now - gameState.lastShotTime < CONFIG.SHOOT_COOLDOWN) return;
            gameState.lastShotTime = now;

            // Flash effect - big and noticeable
            jerkFlash.classList.add('active');
            setTimeout(() => jerkFlash.classList.remove('active'), 150);
            
            // Update gesture indicator
            gestureIndicator.classList.remove('aiming');
            gestureIndicator.classList.add('firing');
            gestureIcon.textContent = 'üí•';
            gestureText.textContent = '–û–ì–û–ù–¨!';
            setTimeout(() => {
                gestureIndicator.classList.remove('firing');
                gestureIndicator.classList.add('aiming');
                gestureIcon.textContent = 'üî´';
                gestureText.textContent = '–¶–µ–ª—å—Å—è';
            }, 200);

            audio.playShoot();

            let hit = false;
            const ax = gameState.aimPosition.x, ay = gameState.aimPosition.y;

            for (const d of discs) {
                if (!d.alive) continue;
                const sp = d.getScreenPos();
                const dist = Math.sqrt((sp.x-ax)**2 + (sp.y-ay)**2);
                if (dist < CONFIG.HIT_RADIUS) {
                    hit = true;
                    particles.emit(d.group.position.x, d.group.position.y, d.group.position.z, 35, d.hue);
                    gameState.score += 100 * gameState.combo;
                    if (now - gameState.lastHitTime < 2000) gameState.combo = Math.min(gameState.combo + 1, 10);
                    gameState.lastHitTime = now;
                    d.respawn();
                    showVFX(`+${100 * gameState.combo}`, sp.x, sp.y, true);
                    audio.playHit();
                    break;
                }
            }

            if (!hit) {
                gameState.combo = 1;
                showVFX('–ú–ò–ú–û', ax, ay, false);
                audio.playMiss();
            }

            scoreDisplay.textContent = gameState.score;
            comboDisplay.textContent = `x${gameState.combo}`;
        }

        function drawLaser() {
            laserCtx.clearRect(0, 0, laserCanvas.width, laserCanvas.height);
            if (!gameState.handVisible || !gameState.isPistolGesture) return;

            const sx = gameState.smoothedAimPosition.x, sy = gameState.smoothedAimPosition.y + 60;
            const ex = gameState.aimPosition.x, ey = gameState.aimPosition.y;

            laserCtx.strokeStyle = gameState.lockedTarget ? 'rgba(0,255,204,0.15)' : 'rgba(255,51,102,0.15)';
            laserCtx.lineWidth = 16;
            laserCtx.lineCap = 'round';
            laserCtx.beginPath();
            laserCtx.moveTo(sx, sy);
            laserCtx.lineTo(ex, ey);
            laserCtx.stroke();

            const grad = laserCtx.createLinearGradient(sx, sy, ex, ey);
            grad.addColorStop(0, 'rgba(255,51,102,0.1)');
            grad.addColorStop(0.5, 'rgba(255,51,102,0.5)');
            grad.addColorStop(1, gameState.lockedTarget ? 'rgba(0,255,204,1)' : 'rgba(255,51,102,1)');
            laserCtx.strokeStyle = grad;
            laserCtx.lineWidth = 3;
            laserCtx.beginPath();
            laserCtx.moveTo(sx, sy);
            laserCtx.lineTo(ex, ey);
            laserCtx.stroke();
        }

        function gameLoop() {
            requestAnimationFrame(gameLoop);

            for (const d of discs) d.update(discs);
            particles.update();

            gameState.smoothedAimPosition.x += (gameState.aimPosition.x - gameState.smoothedAimPosition.x) * CONFIG.SMOOTHING;
            gameState.smoothedAimPosition.y += (gameState.aimPosition.y - gameState.smoothedAimPosition.y) * CONFIG.SMOOTHING;

            const now = Date.now();
            const handRecent = now - gameState.lastHandTime < 400; // –î–æ–ª—å—à–µ –¥–µ—Ä–∂–∏–º –ø—Ä–∏—Ü–µ–ª

            // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø—Ä–∏—Ü–µ–ª –µ—Å–ª–∏ —Ä—É–∫–∞ –≤–∏–¥–Ω–∞ (–¥–∞–∂–µ –±–µ–∑ –∏–¥–µ–∞–ª—å–Ω–æ–≥–æ –∂–µ—Å—Ç–∞)
            if (gameState.handVisible || handRecent) {
                crosshair.style.display = 'block';
                crosshair.style.left = gameState.smoothedAimPosition.x + 'px';
                crosshair.style.top = gameState.smoothedAimPosition.y + 'px';
                
                if (gameState.lockedTarget) {
                    crosshairRing.classList.add('locked');
                    crosshairDot.classList.add('locked');
                } else {
                    crosshairRing.classList.remove('locked');
                    crosshairDot.classList.remove('locked');
                }
                
                // –ú–µ–Ω—è–µ–º –≤–∏–¥ –ø—Ä–∏—Ü–µ–ª–∞ –µ—Å–ª–∏ –Ω–µ –ø–∏—Å—Ç–æ–ª–µ—Ç
                if (gameState.isPistolGesture) {
                    crosshair.style.opacity = '1';
                    shootHint.classList.add('visible');
                    speedMeter.classList.add('visible');
                } else {
                    crosshair.style.opacity = '0.4';
                    shootHint.classList.remove('visible');
                    speedMeter.classList.remove('visible');
                }
                
                // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Å–∫–æ—Ä–æ—Å—Ç—å
                const speed = jerkDetector.getCurrentSpeed();
                const percent = Math.min(speed / (CONFIG.JERK_SPEED_THRESHOLD * 1.25) * 100, 100);
                speedBar.style.width = percent + '%';
            } else {
                crosshair.style.display = 'none';
                shootHint.classList.remove('visible');
                speedMeter.classList.remove('visible');
            }

            if (gameState.currentLandmarks) drawHandTracking(gameState.currentLandmarks);
            drawLaser();
            renderer.render(scene, camera);

            if (now - gameState.lastHitTime > 3000) {
                gameState.combo = 1;
                comboDisplay.textContent = 'x1';
            }
        }

        let hands = null;
        let lastDetection = 0;

        async function processFrame() {
            const now = Date.now();
            if (hands && now - lastDetection >= CONFIG.DETECTION_INTERVAL) {
                lastDetection = now;
                try { await hands.send({ image: webcam }); } catch(e) {}
            }
            requestAnimationFrame(processFrame);
        }

        async function init() {
            try {
                loadingStatus.textContent = '–ó–∞–ø—Ä–æ—Å –∫–∞–º–µ—Ä—ã...';
                loadingBar.style.width = '10%';

                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'user', width: { ideal: 1280 }, height: { ideal: 720 } }
                });
                webcam.srcObject = stream;
                await webcam.play();

                trackingCanvas.width = webcam.videoWidth || 640;
                trackingCanvas.height = webcam.videoHeight || 480;

                loadingStatus.textContent = '–ó–∞–≥—Ä—É–∑–∫–∞ –º–æ–¥–µ–ª–∏...';
                loadingBar.style.width = '30%';

                hands = new Hands({
                    locateFile: (file) => `https://unpkg.com/@mediapipe/hands@0.4.1646424915/${file}`
                });
                hands.setOptions({
                    maxNumHands: 1,
                    modelComplexity: 1,
                    minDetectionConfidence: 0.4,  // –ù–∏–∂–µ = –ª–µ–≥—á–µ –Ω–∞–π—Ç–∏ —Ä—É–∫—É
                    minTrackingConfidence: 0.3    // –ù–∏–∂–µ = —Å—Ç–∞–±–∏–ª—å–Ω–µ–µ —Ç—Ä–µ–∫–∏–Ω–≥
                });

                loadingStatus.textContent = '–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è...';
                loadingBar.style.width = '60%';

                hands.onResults((results) => {
                    try {
                        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                            gameState.handVisible = true;
                            gameState.lastHandTime = Date.now();
                            gameState.currentLandmarks = results.multiHandLandmarks;
                            gameState.isPistolGesture = detectPistolGesture(results.multiHandLandmarks);

                            const h = results.multiHandLandmarks[0];
                            const indexTip = h[8];
                            
                            // –î–æ–±–∞–≤–ª—è–µ–º –ø–æ–∑–∏—Ü–∏—é –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —Ä—ã–≤–∫–∞
                            jerkDetector.addPosition(indexTip.x, indexTip.y);

                            // –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤ —ç–∫—Ä–∞–Ω–Ω—ã–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã
                            const screenX = (1 - indexTip.x) * window.innerWidth;
                            const screenY = indexTip.y * window.innerHeight;
                            
                            const assisted = applyAimAssist(screenX, screenY);
                            gameState.aimPosition = assisted;

                            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –æ—Ç–¥—ë—Ä–≥–∏–≤–∞–Ω–∏–µ –¥–ª—è –≤—ã—Å—Ç—Ä–µ–ª–∞
                            if (gameState.isPistolGesture) {
                                const recoil = jerkDetector.checkJerk();
                                
                                // Debug: –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –≤ –∫–æ–Ω—Å–æ–ª–∏ –∫–æ–≥–¥–∞ –µ—Å—Ç—å –¥–≤–∏–∂–µ–Ω–∏–µ
                                if (recoil.speed > 0.15) {
                                    console.log(`Back: ${recoil.backSpeed.toFixed(2)}, Up: ${recoil.upSpeed.toFixed(2)}, Total: ${recoil.speed.toFixed(2)}`);
                                }
                                
                                if (recoil.detected) {
                                    shoot();
                                }
                            }

                            // UI
                            gestureIndicator.classList.remove('aiming', 'firing');
                            if (gameState.isPistolGesture) {
                                gestureIcon.textContent = 'üî´';
                                gestureText.textContent = '–¶–µ–ª—å—Å—è';
                                gestureIndicator.classList.add('aiming');
                            } else {
                                gestureIcon.textContent = 'üëÜ';
                                gestureText.textContent = '–ü–∏—Å—Ç–æ–ª–µ—Ç';
                            }
                        } else {
                            gameState.handVisible = false;
                            gameState.isPistolGesture = false;
                            gameState.currentLandmarks = null;
                            gestureIndicator.classList.remove('aiming', 'firing');
                            gestureIcon.textContent = '‚úã';
                            gestureText.textContent = '–ü–æ–∫–∞–∂–∏ —Ä—É–∫—É';
                            trackingCtx.clearRect(0, 0, trackingCanvas.width, trackingCanvas.height);
                            jerkDetector.clear();
                        }
                    } catch(e) {}
                });

                loadingStatus.textContent = '–ó–∞–≥—Ä—É–∑–∫–∞ –≤–µ—Å–æ–≤...';
                loadingBar.style.width = '80%';

                await new Promise(resolve => {
                    const check = async () => {
                        try { await hands.send({ image: webcam }); resolve(); }
                        catch(e) { setTimeout(check, 100); }
                    };
                    setTimeout(check, 500);
                });

                loadingStatus.textContent = '–°–æ–∑–¥–∞–Ω–∏–µ –º–∏—à–µ–Ω–µ–π...';
                loadingBar.style.width = '90%';

                for (let i = 0; i < CONFIG.DISC_COUNT; i++) discs.push(new Disc(i));

                loadingStatus.textContent = '–ì–æ—Ç–æ–≤–æ!';
                loadingBar.style.width = '100%';

                setTimeout(() => {
                    loadingOverlay.classList.add('hidden');
                    document.addEventListener('click', () => audio.init(), { once: true });
                    document.addEventListener('touchstart', () => audio.init(), { once: true });
                    audio.init();
                    gameLoop();
                    processFrame();
                }, 500);

            } catch (e) {
                loadingStatus.textContent = `–û—à–∏–±–∫–∞: ${e.message}`;
            }
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            laserCanvas.width = window.innerWidth;
            laserCanvas.height = window.innerHeight;
        });

        init();
    </script>
</body>
</html>
